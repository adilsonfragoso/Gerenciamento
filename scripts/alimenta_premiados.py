#Esse script usa um script chamado "calculo_valor_real.py" para calcular o valor real dos pr√™mios.



from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from time import sleep
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import TimeoutException, NoSuchElementException, ElementClickInterceptedException
import unidecode
import os
import sys
import re
import mysql.connector
from mysql.connector import Error
import argparse
import contextlib
import re

# ===================== CONFIGURA√á√ÉO =====================
HEADLESS = False  # False para debug, True para produ√ß√£o
LOG_FILE = None   # Caminho do log se em modo oculto
driver_path = r"D:\Documentos\Workspace\chromedriver.exe"
service = Service(driver_path)


sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from app.db_config import DB_CONFIG

def calcular_valor_real(premio):
    valor_reais = 0.0
    match_reais = re.search(r'R\$\s*([\d\.]+,\d{2})', premio)
    if match_reais:
        valor_reais = float(match_reais.group(1).replace('.', '').replace(',', '.'))
    match_cotas = re.search(r'(\d+)\s+COTAS?\s+DO\s+SORTEIO\s+DA\s+(.+)', premio, re.IGNORECASE)
    valor_cotas = 0.0
    if match_cotas:
        qtd_cotas = int(match_cotas.group(1))
        nome_cota = match_cotas.group(2).strip().upper()
        conexao = conectar_banco()
        if conexao:
            try:
                cursor = conexao.cursor()
                cursor.execute("SELECT valor_cota FROM cotas WHERE UPPER(cota) LIKE %s LIMIT 1", (f"%{nome_cota}%",))
                resultado = cursor.fetchone()
                if resultado:
                    valor_unitario = float(resultado[0])
                    valor_cotas = qtd_cotas * valor_unitario
            finally:
                cursor.close()
                conexao.close()
    return round(valor_reais + valor_cotas, 2)

def configurar_oculto():
    global HEADLESS, LOG_FILE
    HEADLESS = True
    LOG_FILE = os.path.join(os.path.dirname(__file__), 'alimenta_premiados_oculto.log')
    # Redirecionar prints para arquivo
    class Logger:
        def __init__(self, filename):
            self.terminal = sys.stdout
            self.log = open(filename, 'a', encoding='utf-8')
        def write(self, message):
            self.terminal.write(message)
            self.log.write(message)
        def flush(self):
            self.terminal.flush()
            self.log.flush()
    sys.stdout = Logger(LOG_FILE)
    sys.stderr = Logger(LOG_FILE)

def criar_navegador():
    if HEADLESS:
        opts = Options()
        opts.add_argument('--headless=new')
        opts.add_argument('--disable-gpu')
        opts.add_argument('--no-sandbox')
        opts.add_argument('--window-size=1920,1080')
        return webdriver.Chrome(service=service, options=opts)
    else:
        return webdriver.Chrome(service=service)

def conectar_banco():
    """Conecta ao banco MySQL"""
    try:
        conexao = mysql.connector.connect(**DB_CONFIG)
        return conexao
    except Error as e:
        print(f"‚ùå Erro ao conectar ao banco: {e}")
        return None

def inserir_premiacao(edicao, extracao, nome, telefone, colocacao, premio, titulo, valor_real=None):
    """Insere uma premia√ß√£o na tabela premiados"""
    conexao = conectar_banco()
    if not conexao:
        return False
    
    try:
        cursor = conexao.cursor()
        if valor_real is None:
            valor_real = calcular_valor_real(premio)
        query = """
        INSERT INTO premiados (edicao, extracao, nome, telefone, colocacao, premio, titulo, valor_real)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
        """
        valores = (edicao, extracao, nome, telefone, colocacao, premio, titulo, valor_real)
        cursor.execute(query, valores)
        conexao.commit()
        print(f"‚úÖ Premia√ß√£o {colocacao}¬∫ lugar salva no banco: {nome} | valor_real: {valor_real}")
        return True
    except Error as e:
        print(f"‚ùå Erro ao inserir premia√ß√£o: {e}")
        return False
    finally:
        if conexao.is_connected():
            cursor.close()
            conexao.close()

def obter_maior_edicao_premiados():
    """Obt√©m a maior edi√ß√£o j√° processada na tabela premiados"""
    conexao = conectar_banco()
    if not conexao:
        return 0
    
    try:
        cursor = conexao.cursor()
        cursor.execute("SELECT MAX(edicao) FROM premiados")
        resultado = cursor.fetchone()
        maior_edicao = resultado[0] if resultado and resultado[0] is not None else 0
        return maior_edicao
        
    except Error as e:
        print(f"‚ùå Erro ao consultar premiados: {e}")
        return 0
        
    finally:
        if conexao.is_connected():
            cursor.close()
            conexao.close()

def obter_maior_edicao_extracoes():
    """Obt√©m a maior edi√ß√£o dispon√≠vel na tabela extracoes_cadastro com andamento 100%"""
    conexao = conectar_banco()
    if not conexao:
        return 0
    
    try:
        cursor = conexao.cursor()
        cursor.execute("SELECT MAX(edicao) FROM extracoes_cadastro WHERE andamento = '100%'")
        resultado = cursor.fetchone()
        maior_edicao = resultado[0] if resultado and resultado[0] is not None else 0
        return maior_edicao
        
    except Error as e:
        print(f"‚ùå Erro ao consultar extracoes_cadastro: {e}")
        return 0
        
    finally:
        if conexao.is_connected():
            cursor.close()
            conexao.close()

def obter_maior_edicao_disponivel():
    """Obt√©m a maior edi√ß√£o dispon√≠vel na tabela extracoes_cadastro independente do andamento"""
    conexao = conectar_banco()
    if not conexao:
        return 0
    
    try:
        cursor = conexao.cursor()
        cursor.execute("SELECT MAX(edicao) FROM extracoes_cadastro")
        resultado = cursor.fetchone()
        maior_edicao = resultado[0] if resultado and resultado[0] is not None else 0
        return maior_edicao
        
    except Error as e:
        print(f"‚ùå Erro ao consultar extracoes_cadastro: {e}")
        return 0
        
    finally:
        if conexao.is_connected():
            cursor.close()
            conexao.close()

def fazer_login(navegador):
    print("üîê Fazendo login...")
    navegador.get("https://painel.litoraldasorte.com")
    sleep(2)
    navegador.execute_script("window.print = function(){};")
    navegador.find_element(By.NAME, "email").send_keys("relatoriodash")
    navegador.find_element(By.NAME, "password").send_keys("Define@4536#8521")
    navegador.find_element(By.CSS_SELECTOR, "button[type='submit']").click()
    sleep(3)
    print("‚úÖ Login realizado")

def fechar_popup(navegador):
    try:
        btn = WebDriverWait(navegador, 5).until(
            EC.element_to_be_clickable((By.XPATH, "//button[normalize-space(text())='Entendi']"))
        )
        btn.click()
        WebDriverWait(navegador, 5).until(
            EC.invisibility_of_element_located((By.CSS_SELECTOR, "div.MuiDialog-container"))
        )
        print("‚úÖ Pop-up fechado")
    except TimeoutException:
        pass

def limpar_overlays(navegador):
    """Remove overlays que bloqueiam cliques"""
    try:
        # Pressionar ESC para fechar modais
        body = navegador.find_element(By.TAG_NAME, "body")
        for _ in range(3):
            body.send_keys(Keys.ESCAPE)
            sleep(0.3)
        
        # Remover backdrops via JavaScript
        navegador.execute_script("""
            document.querySelectorAll('div.MuiBackdrop-root').forEach(backdrop => {
                if (backdrop.style.opacity !== '0') {
                    backdrop.remove();
                }
            });
        """)
        
        sleep(1)
        print("üßπ Overlays removidos")
        
    except Exception as e:
        print(f"‚ö†Ô∏è Aviso limpeza: {e}")

def limpar_campo_busca(navegador):
    """Limpa completamente o campo de busca"""
    try:
        campo = navegador.find_element(By.XPATH, "//input[@placeholder='Pesquisar por t√≠tulo do sorteio...']")
        campo.click()
        sleep(0.3)
        
        # Selecionar tudo e deletar
        campo.send_keys(Keys.CONTROL + "a")
        sleep(0.2)
        campo.send_keys(Keys.DELETE)
        sleep(0.2)
        
        # Garantir que est√° vazio via JavaScript
        navegador.execute_script("arguments[0].value = '';", campo)
        navegador.execute_script("arguments[0].dispatchEvent(new Event('input', { bubbles: true }));", campo)
        
        print("üßπ Campo de busca limpo")
        return True
        
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao limpar campo: {e}")
        return False

def navegar_para_sorteios(navegador):
    try:
        # Limpar qualquer overlay
        limpar_overlays(navegador)
        
        # Tentar clicar no menu sorteios
        menu_xpath = '//*[@id="root"]/div/div/div/div/div/div/div[1]/div[2]/div/div/div/div[2]/ul[1]/div[2]/div[2]/span'
        
        # Aguardar elemento estar clic√°vel
        menu = WebDriverWait(navegador, 10).until(
            EC.element_to_be_clickable((By.XPATH, menu_xpath))
        )
        
        # Usar JavaScript para garantir o clique
        navegador.execute_script("arguments[0].scrollIntoView(true);", menu)
        sleep(1)
        navegador.execute_script("arguments[0].click();", menu)
        sleep(2)
        
        # Limpar campo de busca ap√≥s navegar
        limpar_campo_busca(navegador)
        
        print("üìã Navegando para sorteios...")
        return True
        
    except Exception as e:
        print(f"‚ùå Erro ao navegar para sorteios: {e}")
        return False

def extrair_informacoes_reveladas(navegador):
    """Extrai nomes, telefones, t√≠tulos e pr√™mios organizados por premia√ß√£o"""
    try:
        print("üìã Extraindo informa√ß√µes completas por premia√ß√£o...")
        
        # Aguardar um pouco para garantir que as informa√ß√µes carregaram
        sleep(2)
        
        # Buscar todas as divs de premia√ß√£o (cada pr√™mio tem sua div)
        divs_premiacoes = navegador.find_elements(By.CSS_SELECTOR, "div.css-1bnl7m3")
        
        premiacoes = {}
        
        print(f"üèÜ Encontradas {len(divs_premiacoes)} premia√ß√µes")
        
        for i, div_premiacao in enumerate(divs_premiacoes, 1):
            try:
                # Extrair a coloca√ß√£o do pr√™mio (1¬∫, 2¬∫, etc.)
                try:
                    paragrafo_colocacao = div_premiacao.find_element(By.TAG_NAME, "p")
                    colocacao_texto = paragrafo_colocacao.text.strip()
                    # Extrair apenas o n√∫mero da coloca√ß√£o
                    import re
                    match = re.search(r'(\d+)', colocacao_texto)
                    colocacao = match.group(1) if match else str(i)
                except:
                    colocacao = str(i)
                
                # Buscar a div que cont√©m os dados do ganhador
                try:
                    div_dados = div_premiacao.find_element(By.CSS_SELECTOR, "div.css-1pq59s1")
                    
                    # Extrair nome (primeiro h1)
                    nome = ""
                    try:
                        h1_nome = div_dados.find_element(By.TAG_NAME, "h1")
                        nome = h1_nome.text.strip()
                    except:
                        nome = "Nome n√£o encontrado"
                    
                    # Extrair telefone (span com classe espec√≠fica)
                    telefone = ""
                    try:
                        span_telefone = div_dados.find_element(By.CSS_SELECTOR, "span.css-okm2xv")
                        telefone = span_telefone.text.strip()
                        # Remover o prefixo "Telefone: " se existir
                        if telefone.startswith("Telefone: "):
                            telefone = telefone.replace("Telefone: ", "")
                    except:
                        telefone = "Telefone n√£o encontrado"
                    
                    # Extrair t√≠tulo (span com classe css-1kqhtuk)
                    titulo = ""
                    try:
                        span_titulo = div_dados.find_element(By.CSS_SELECTOR, "span.css-1kqhtuk")
                        titulo = span_titulo.text.strip()
                        # Remover o prefixo "T√≠tulo: " se existir
                        if titulo.startswith("T√≠tulo: "):
                            titulo = titulo.replace("T√≠tulo: ", "")
                    except:
                        titulo = "T√≠tulo n√£o encontrado"
                    
                    # Extrair pr√™mio (span com classe css-176slt)
                    premio = ""
                    try:
                        span_premio = div_dados.find_element(By.CSS_SELECTOR, "span.css-176slt")
                        premio = span_premio.text.strip()
                        # Remover o prefixo "Pr√™mio: " se existir
                        if premio.startswith("Pr√™mio: "):
                            premio = premio.replace("Pr√™mio: ", "")
                    except:
                        premio = "Pr√™mio n√£o encontrado"
                    
                    # Armazenar informa√ß√µes completas da premia√ß√£o
                    premiacoes[f"{colocacao}¬∫ Pr√™mio"] = {
                        'nome': nome,
                        'telefone': telefone,
                        'titulo': titulo,
                        'premio': premio,
                        'colocacao': colocacao
                    }
                    
                    print(f"üèÜ {colocacao}¬∫ Pr√™mio: {nome} | T√≠tulo: {titulo} | Pr√™mio: {premio} | Tel: {telefone}")
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Erro ao extrair dados da premia√ß√£o {i}: {e}")
                    continue
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao processar div de premia√ß√£o {i}: {e}")
                continue
        
        return premiacoes
        
    except Exception as e:
        print(f"‚ùå Erro ao extrair informa√ß√µes: {e}")
        return {}

def revelar_informacoes_ocultas(navegador, cabecalho):
    """Clica em TODOS os √≠cones do olho para revelar todas as informa√ß√µes"""
    try:
        # Aguardar carregar o div principal das premia√ß√µes
        div_principal = WebDriverWait(navegador, 10).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, "div.css-cuz3o0"))
        )
        print("‚úÖ Div principal das premia√ß√µes carregado")
        
        cliques_sucesso = 0
        todos_svgs_clicados = []
        
        print("üéØ Procurando SVG do olho pelas classes espec√≠ficas...")
        print("üîç Classes alvo: css-d0uhtl (que funciona) e css-hjsfpi (2¬∫ pr√™mio teste)")
        
        try:
            # Aguardar elementos SVG aparecerem
            print("‚è≥ Aguardando elementos SVG aparecerem...")
            elementos_svg = WebDriverWait(navegador, 10).until(
                EC.presence_of_all_elements_located((By.CSS_SELECTOR, "svg.iconify.iconify--ic"))
            )
            
            print(f"‚úÖ Encontrados {len(elementos_svg)} SVGs com classes iconify!")
            
                         # Procurar especificamente pelo SVG com as classes corretas
            elemento_svg = None
            svgs_candidatos = []
            
            for i, svg in enumerate(elementos_svg, 1):
                try:
                    classes = svg.get_attribute('class') or ""
                    
                    # Verificar se tem as classes espec√≠ficas dos √≠cones olho 
                    if ("css-d0uhtl" in classes or "css-hjsfpi" in classes) and "iconify" in classes:
                        if "css-d0uhtl" in classes:
                            todos_svgs_clicados.append((svg, i, "css-d0uhtl"))
                        elif "css-hjsfpi" in classes:
                            todos_svgs_clicados.append((svg, i, "css-hjsfpi"))
                    # Se n√£o encontrar os exatos, guardar candidatos pr√≥ximos
                    elif ("css-d0" in classes or "css-n2e6h8" in classes or "css-h" in classes) and "iconify" in classes:
                        svgs_candidatos.append((svg, i, classes))
                        
                except Exception:
                    continue
            
            # VERS√ÉO OTIMIZADA - Cliques r√°pidos sem logs excessivos
            if todos_svgs_clicados:
                print(f"‚úÖ Encontrados {len(todos_svgs_clicados)} √≠cones para clicar - iniciando cliques r√°pidos...")
                
                # Clicar rapidamente em todos
                for i, (svg, num, tipo) in enumerate(todos_svgs_clicados, 1):
                    try:
                        if svg.is_displayed():
                            svg.click()
                            cliques_sucesso += 1
                            print(f"üëÅÔ∏è {i}/{len(todos_svgs_clicados)} ‚úÖ", end=" ")
                            #sleep(0.1)  # Pausa m√≠nima
                    except:
                        print(f"‚ùå {i}", end=" ")
                        continue
                
                print()  # Nova linha ap√≥s todos os cliques
                
                # Extrair informa√ß√µes apenas uma vez no final
                print("\nüìä EXTRAINDO INFORMA√á√ïES POR PREMIA√á√ÉO...")
                premiacoes = extrair_informacoes_reveladas(navegador)
                
                # Mostrar resultado organizado por premia√ß√£o
                if premiacoes:
                    print("\nüèÜ RESULTADOS COMPLETOS POR PREMIA√á√ÉO:")
                    print("=" * 80)
                    print(f"üìù SIGLA: {cabecalho['sigla']}")
                    print(f"üî¢ EDI√á√ÉO: {cabecalho['edicao']}")
                    print(f"üìÑ TEXTO COMPLETO: {cabecalho['texto_completo']}")
                    print("=" * 80)
                    
                    premiacao_salvas = 0
                    
                    for colocacao, dados in premiacoes.items():
                        print(f"\nü•á {colocacao}:")
                        print(f"   üë§ Nome: {dados['nome']}")
                        print(f"   üìû Telefone: {dados['telefone']}")
                        print(f"   üé´ T√≠tulo: {dados['titulo']}")
                        print(f"   üèÜ Pr√™mio: {dados['premio']}")
                        
                        # Extrair n√∫mero da coloca√ß√£o (1¬∫, 2¬∫, etc.)
                        colocacao_numero = dados['colocacao']
                        
                        # Inserir no banco MySQL
                        if inserir_premiacao(
                            edicao=cabecalho['edicao'],
                            extracao=cabecalho['sigla'], 
                            nome=dados['nome'],
                            telefone=dados['telefone'],
                            colocacao=colocacao_numero,
                            premio=dados['premio'],
                            titulo=dados['titulo']
                        ):
                            premiacao_salvas += 1
                    
                    print(f"\nüíæ BANCO DE DADOS: {premiacao_salvas}/{len(premiacoes)} premia√ß√µes salvas!")
                    print(f"‚úÖ TOTAL: {len(premiacoes)} premia√ß√µes encontradas!")
                    print("=" * 80)
                else:
                    print("‚ö†Ô∏è Nenhuma premia√ß√£o encontrada")
                        
            # Se n√£o encontrou nenhum SVG espec√≠fico, tentar candidatos
            elif svgs_candidatos:
                print(f"‚ö†Ô∏è Nenhum SVG espec√≠fico encontrado. Testando {len(svgs_candidatos)} candidatos...")
                
                # Usar apenas o primeiro candidato em card de premia√ß√£o
                for svg, num, classes in svgs_candidatos:
                    try:
                        # Verificar se o SVG est√° dentro de um card de premia√ß√£o
                        elemento_pai = svg.find_element(By.XPATH, "./ancestor::div[contains(@class, 'MuiCard-root')]")
                        if elemento_pai:
                            print(f"üéØ Usando candidato {num}: {classes}")
                            todos_svgs_clicados = [(svg, num, "candidato")]
                            break
                    except:
                        continue
            
            else:
                print(f"‚ö†Ô∏è EDI√á√ÉO {cabecalho['edicao']}: Nenhum SVG de premia√ß√£o encontrado - possivelmente sem premia√ß√µes")
                
        except TimeoutException:
            print(f"‚ö†Ô∏è EDI√á√ÉO {cabecalho['edicao']}: Timeout - elementos n√£o carregaram (possivelmente sem premia√ß√µes)")
        except Exception as e:
            print(f"‚ö†Ô∏è EDI√á√ÉO {cabecalho['edicao']}: Erro geral - {str(e)[:50]}")
        
        print(f"\n‚úÖ Total de cliques realizados: {cliques_sucesso}")
        
        # Se n√£o conseguiu clicar em nenhum √≠cone, significa que n√£o h√° premia√ß√µes
        if cliques_sucesso == 0:
            print(f"üìù EDI√á√ÉO {cabecalho['edicao']}: SEM PREMIA√á√ïES ATRIBU√çDAS")
            print("=" * 60)
            print(f"üìù SIGLA: {cabecalho['sigla']}")
            print(f"üî¢ EDI√á√ÉO: {cabecalho['edicao']}")
            print(f"‚ö†Ô∏è STATUS: Sem premia√ß√µes para exibir")
            print("=" * 60)
        
        # Aguardar um pouco para que as informa√ß√µes carreguem
        sleep(1)  # Reduzido para 1 segundo
        
        return True  # Sempre retorna True para n√£o interromper o processamento em lote
        
    except Exception as e:
        print(f"‚ùå EDI√á√ÉO {cabecalho['edicao']}: Erro cr√≠tico - {e}")
        return True  # Mesmo com erro, continua o processamento

def digitar_edicao_e_clicar_compras(navegador, edicao):
    """Digita a edi√ß√£o no campo de busca, clica em Compras e revela informa√ß√µes"""
    print(f"\nüöÄ Processando edi√ß√£o: {edicao}")
    
    try:
        # Garantir que campo est√° limpo antes de digitar
        limpar_campo_busca(navegador)
        sleep(1)
        
        campo = navegador.find_element(By.XPATH, "//input[@placeholder='Pesquisar por t√≠tulo do sorteio...']")
        campo.click()
        sleep(0.5)
        campo.send_keys(str(edicao))
        sleep(1)  # Reduzido para 1 segundo
        print(f"üîç Digitado: {edicao}")
        
        # Verificar se encontrou algum resultado
        try:
            # Aguardar aparecer bot√£o "Compras"
            compras_btn = WebDriverWait(navegador, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//button[@aria-label='Compras']"))
            )
            print(f"‚úÖ Edi√ß√£o {edicao} encontrada")
            
            # EXTRAIR SIGLA ANTES de clicar em Compras
            sigla_extraida = extrair_sigla_da_pesquisa(navegador)
            
            # Clicar no bot√£o Compras
            compras_btn.click()
            sleep(2)  # Reduzido para 2 segundos
            print(f"‚úÖ Clicou em Compras para edi√ß√£o {edicao}")
            
            # Criar objeto cabe√ßalho com as informa√ß√µes extra√≠das
            cabecalho = {
                'sigla': sigla_extraida,
                'edicao': str(edicao),
                'texto_completo': f"{sigla_extraida} EDI√á√ÉO {edicao}"
            }
            
            # Revelar informa√ß√µes ocultas
            print("üëÅÔ∏è Procurando √≠cones de olho para revelar informa√ß√µes...")
            sucesso_revelacao = revelar_informacoes_ocultas(navegador, cabecalho)
            
            if sucesso_revelacao:
                print("‚úÖ Informa√ß√µes reveladas com sucesso!")
            else:
                print("‚ö†Ô∏è N√£o foi poss√≠vel revelar todas as informa√ß√µes")
            
            # Para processamento em lote, n√£o pausar
            # print(f"\n‚è∏Ô∏è PAUSANDO ap√≥s revelar informa√ß√µes da edi√ß√£o {edicao}")
            # print("üîç Verifique se as informa√ß√µes foram reveladas corretamente")
            # input("Pressione ENTER para continuar...")
            
            return True
            
        except TimeoutException:
            print(f"‚ùå Nenhum resultado encontrado para a edi√ß√£o {edicao}")
            return False
        except NoSuchElementException:
            print(f"‚ùå Bot√£o Compras n√£o encontrado para a edi√ß√£o {edicao}")
            return False
        
    except Exception as e:
        print(f"‚ùå Erro ao processar edi√ß√£o {edicao}: {e}")
        return False

def extrair_sigla_da_pesquisa(navegador):
    """Extrai a sigla da div de resultado da pesquisa"""
    try:
        print("üìã Extraindo sigla da p√°gina de pesquisa...")
        
        # Buscar a div com o resultado da pesquisa que cont√©m a informa√ß√£o da edi√ß√£o
        # Procurar por elementos que contenham texto sobre a edi√ß√£o
        elementos_resultado = navegador.find_elements(By.XPATH, "//*[contains(@class, 'MuiTypography')]")
        
        for elemento in elementos_resultado:
            try:
                texto = elemento.text.strip()
                # Procurar por texto que contenha padr√µes de edi√ß√£o
                if texto and len(texto) > 10 and any(palavra in texto.upper() for palavra in ['EDI√á√ÉO', 'EDITION', 'ED.']):
                    print(f"üéØ Texto encontrado: '{texto}'")
                    
                    sigla = ""
                    
                    # Aplicar as regras de extra√ß√£o
                    if "RJ" in texto:
                        # Se cont√©m "RJ", a sigla √© o que vem antes de "RJ"
                        partes = texto.split("RJ")
                        sigla = partes[0].strip()
                    elif "EDI√á√ÉO" in texto:
                        # Se n√£o cont√©m "RJ", a sigla √© o que vem antes de "EDI√á√ÉO"
                        partes = texto.split("EDI√á√ÉO")
                        sigla = partes[0].strip()
                    elif "EDITION" in texto:
                        # Varia√ß√£o em ingl√™s
                        partes = texto.split("EDITION")
                        sigla = partes[0].strip()
                    
                    if sigla:
                        print(f"‚úÖ Sigla extra√≠da: '{sigla}'")
                        return sigla
                        
            except Exception:
                continue
        
        print("‚ö†Ô∏è Nenhuma sigla encontrada na pesquisa")
        return "Sigla n√£o encontrada"
        
    except Exception as e:
        print(f"‚ùå Erro ao extrair sigla: {e}")
        return "Erro na extra√ß√£o"

def main():
    parser = argparse.ArgumentParser(description='Alimentador autom√°tico de premia√ß√µes')
    parser.add_argument('--oculto', '-o', action='store_true', help='Executa em modo oculto (headless, sem prints no terminal)')
    args = parser.parse_args()

    if args.oculto:
        configurar_oculto()

    print("üöÄ ALIMENTADOR AUTOM√ÅTICO DE PREMIA√á√ïES")
    print("=" * 50)
    
    # Obter faixa de edi√ß√µes para processar
    print("üìä Consultando banco de dados...")
    maior_processada = obter_maior_edicao_premiados()
    maior_disponivel_100 = obter_maior_edicao_extracoes()
    maior_disponivel_total = obter_maior_edicao_disponivel()
    
    if maior_disponivel_100 == 0:
        print("‚ùå Nenhuma edi√ß√£o com andamento 100% encontrada na tabela extracoes_cadastro")
        return
    
    edicao_inicial = maior_processada + 1
    edicao_final = maior_disponivel_100
    
    if edicao_inicial > edicao_final:
        print(f"‚úÖ Todas as edi√ß√µes com andamento 100% j√° foram processadas!")
        print(f"üìä √öltima edi√ß√£o processada com 100%: {maior_processada}")
        print(f"üìä Maior edi√ß√£o em andamento: {maior_disponivel_total}")
        return
    
    print(f"üéØ Faixa de processamento: {edicao_inicial} at√© {edicao_final} (andamento 100%)")
    print(f"üìä Total de edi√ß√µes para processar: {edicao_final - edicao_inicial + 1}")
    print("=" * 50)
    
    navegador = criar_navegador()
    
    try:
        # Login √∫nico
        print("üîê Iniciando sess√£o...")
        fazer_login(navegador)
        fechar_popup(navegador)
        sleep(2)
        
        # Ir para sorteios
        if not navegar_para_sorteios(navegador):
            print("‚ùå Falha inicial sorteios")
            return
        
        sucessos = 0
        falhas = 0
        
        # Processar edi√ß√µes sequencialmente
        for edicao_atual in range(edicao_inicial, edicao_final + 1):
            print(f"\nüîÑ PROCESSANDO EDI√á√ÉO {edicao_atual} ({edicao_atual - edicao_inicial + 1}/{edicao_final - edicao_inicial + 1})")
            
            try:
                resultado = digitar_edicao_e_clicar_compras(navegador, edicao_atual)
                
                if resultado:
                    sucessos += 1
                    print(f"‚úÖ Edi√ß√£o {edicao_atual} processada com sucesso!")
                else:
                    falhas += 1
                    print(f"‚ùå Falha ao processar edi√ß√£o {edicao_atual}")
                
                # Navegar de volta para sorteios (exceto na √∫ltima edi√ß√£o)
                if edicao_atual < edicao_final:
                    print("üîÑ Voltando para sorteios...")
                    if not navegar_para_sorteios(navegador):
                        print("‚ùå Erro ao voltar para sorteios - interrompendo processamento")
                        break
                    sleep(1)  # Pequena pausa entre edi√ß√µes
                
            except Exception as e:
                falhas += 1
                print(f"‚ùå Erro cr√≠tico na edi√ß√£o {edicao_atual}: {e}")
                
                # Tentar recuperar navegando de volta para sorteios
                try:
                    print("üîÑ Tentando recuperar navega√ß√£o...")
                    navegar_para_sorteios(navegador)
                except:
                    print("‚ùå N√£o foi poss√≠vel recuperar - interrompendo")
                    break
        
        # Relat√≥rio final
        print("\n" + "=" * 60)
        print("üéâ PROCESSAMENTO CONCLU√çDO!")
        print("=" * 60)
        print(f"‚úÖ Sucessos: {sucessos}")
        print(f"‚ùå Falhas: {falhas}")
        print(f"üìä Total processado: {sucessos + falhas}")
        print(f"üìä Faixa processada: {edicao_inicial} - {edicao_inicial + sucessos + falhas - 1}")
        if sucessos > 0:
            print(f"üéØ Nova maior edi√ß√£o processada: {edicao_inicial + sucessos - 1}")
        print("=" * 60)
        
    except Exception as e:
        print(f"‚ùå Erro cr√≠tico no processamento: {e}")
    finally:
        print("üîí Fechando navegador...")
        navegador.quit()

if __name__ == "__main__":
    main()